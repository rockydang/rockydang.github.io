---
layout:     post
title:      Lock锁相关
subtitle:    "\"技术博客列表\""
date:       2017-02-15
author:     rockybobo
header-img: img/myname/post_20170212_01.jpg
catalog: true
tags:
    - 技术
---

## Lock相关

1. lock()  阻塞式地获取锁，只有在获取到锁后才处理interrupt信息
2. lockInterruptibly() 阻塞式地获取锁，立即处理interrupt信息，并抛出异常；
3. tryLock()  尝试获取锁，不管成功失败，都立即返回true、false
4. tryLock(long timeout, TimeUnit unit)在timeout时间内阻塞式地获取锁，成功返回true，超时返回false，同时立即处理interrupt信息，并抛出异常；

#### ReentrantLock 与 Synchorized

相同点：

1. ReentrantLock实现了Lock接口，并且提供了与synchronized相同的互斥性、和内存可见性。在获取ReentrantLock时，有着与进入同步代码块相同的内存语义，在释放ReentrantLock时，同样有与退出同步代码块相同的语义；
2. ReentrantLock还提供了可重入的加锁语义；
3. ReentrantLock支持在Lock接口中定义的所有获取锁的模式，并且与synchronized相比，它还为处理锁的不可用性问题提供了更高的灵活性；

不同点：

1. 内置锁的局限性：

   a. 无法中断一个正在等待获取锁的线程；

   b.无法在请求中获取一个锁时无限地等待下去；

   c.必须在获取该锁的代码块中释放，虽然简化了编码工作并且与异常处理操作实现了很好的交互，但却无法实现非阻塞结构的加锁规则；

2. Lock提供了一种：无条件的、可轮询的、定时的、可中断的锁获取操作；并且所有加锁、解锁的方式都是显示的；

3. Lock比使用内置锁更复杂一些：

   a.必须在finally块中释放锁；

   b.必须考虑在try块中抛出异常的情况，如果可能使对象处于某一种不一致的状态，那么就需要更多的 try-catch或try-finally代码块；

##### ReentrantLock

* 轮询锁

   a.如果不能获取所有需要的锁，那么可以使用可定时或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁；使用trylock来获取两个锁，如果不能同时获得，那么就回退并重新尝试；

  b. 如果在指定时间内不能获取所有需要的锁，那么操作将平缓失败，避免出现死锁；

* 定时锁

   当在带有时间限制的操作中调用了一个阻塞方法时，它能根据剩余时间来提供一个时限；如果操作不能在指定时间内给出结果，那么就会是使程序提前结束；

* 可中断锁

  如定时的锁获取操作在带有时间限制的操作中使用独占锁，可中断的锁获取操作同样能在可取消的操作中使用加锁；

* 非块结构的加锁

  在内置锁中，锁的获取和释放等操作都是基于代码块的。释放锁的操作与获取锁的操作都是处于同一个代码块，而不考虑控制权如何退出该代码块。

  自动的锁释放操作简化了对程序的分析，避免了编码错误，但是不灵活；

* 公平性

  > 公平锁：公平情况下，操作会排一个队按顺序执行，来保证执行顺序。（会消耗更多的时间来排队）
  >
  > 不公平锁：无序状态允许插队，jvm会自动计算如何处理更快速来调度插队。（如果不关心顺序，这个速度会更快）

* 性能考虑

  a. 如果有越多的资源耗费在锁的管理和调度上，那么应用程序得到的资源就越少

  b.锁的实现方式越好，将需要越少的系统调用和上下文切换，并且在共享内存总线上的内存同步通信量也越少，而一些耗时的操作将占用应用程序的计算资源；

  c.java 5.0版本 ReentrantLock有比内置锁更高的吞吐量；

     在java 6.0对synchoronized做了优化后，两者吞吐量差不多；

     

##### synchronized与ReentrantLock之前进行选择

1. ReentrantLock在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能：定时的锁等待、可中断的锁、公平性、实现非块结构的加锁。

2. ReentrantLock在性能上似乎更由于内置锁；Java6中略有胜出、Java5中远远胜出；

3. 内置锁的优势

   a.许多开发人员熟悉，并且简洁紧凑，而且在许多现有的程序中都已经使用了内置锁；

   b.ReentrantLock的危险性比同步机制要高，如果忘记在finally中调用unlock,可能出现死锁；

   c.Java5中内置锁在线程存储中能给出在哪些调用帧中获得了哪些锁，并能够监测和识别发生死锁的线程；

      而Jvm并不知道哪些线程持有ReentrantLock,因此在调试使用ReentrantLock的线程问题 时，将起不到帮助作用；

   d.java6中解决了上述问题提哦功能了一个管理、调试接口；

4. 所以仅仅在内置锁不能满足需求时，才可以考虑使用ReentrantLock

   ​

##### 读-写锁







